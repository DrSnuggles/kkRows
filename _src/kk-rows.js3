`], {type:'text/javascript'})
		const worker = new Worker(URL.createObjectURL(blob))

		this.worker = worker	// store for later
		worker.onmessage = (e) => {
			//console.log('From worker', e.data)
			const dat = e.data
			if (dat.tbl) {
				//document.body.insertAdjacentHTML('beforeEnd', dat.tbl)

				// update scrollbar
				const myTblScroll = this._shadowRoot.getElementById('myTblScroll')
				myTblScroll.value = dat.actRow / dat.len
				myTblScroll.title = `${dat.actRow+1}-${(dat.endRow<dat.len) ? dat.endRow : dat.len} / ${dat.len}`

				const myTblDiv = this._shadowRoot.getElementById('myTblDiv')
				if (myTblDiv.childNodes.length === 0) {
					myTblDiv.innerHTML = dat.tbl
					this.resizer()
				} else {
					myTblDiv.childNodes[0].remove() // important else garbage grows
					myTblDiv.innerHTML = dat.tbl
				}

				return
			}

			if (e.data.resizeNeeded) {
				this.resizer()
				return
			}

			if (e.data.rng) {
				window.kkRowsCallback(e.data.rng, eval(e.data.callback))	// evil eval
				return
			}

			console.log('Unknown message:', e)
		}

		//worker.postMessage({msg:'getRows'})

	} // initWorker

	initHandler() {
		// resize
		const ro = new ResizeObserver(entries => {
			for (let entry of entries) {
			  const cr = entry.contentRect
			  //console.log('Element:', entry.target)
			  //console.log(`Element size: ${cr.width}px x ${cr.height}px`)
			  //console.log(`Element padding: ${cr.top}px ; ${cr.left}px`)
			  this.resizer()
			}
		  })
		  ro.observe( this._shadowRoot.host ) // Observe one or multiple elements

		// wheel
		this.addEventListener('wheel', (e) => { // scroll
			this.worker.postMessage({scroll: {
				deltaX: e.deltaX,
				deltaY: e.deltaY,
			}})
		}, {passive:true})
		this._shadowRoot.getElementById('myTblScroll').oninput = (e) => { // range slider
			this.worker.postMessage({scrollTo: e.target.value*1})
		}

		// search input
		this.keyTimer = null
		this.lastInput = ''
		this._shadowRoot.getElementById('fInput').onkeyup = (e) => {
			const thisInput = e.target.value
			if (this.lastInput !== thisInput) {
				if (this.keyTimer) {
					clearTimeout(this.keyTimer)
					this.keyTimer = null
				}

				this.keyTimer = setTimeout(()=>{
					this.worker.postMessage({filter: this._shadowRoot.getElementById('fInput').value})
				}, 500) // 500ms for next keyup event

				this.lastInput = thisInput
			}

		}
	} // initHandler

	resizer() {
		const myTblDiv = this._shadowRoot.getElementById('myTblDiv')
		const restHeight = this._shadowRoot.getElementById('kkOuter').offsetHeight - 21
		this._shadowRoot.getElementById('myTblScroll').style.width = restHeight +'px'
		this.worker.postMessage({resize: {
			//width: myTblDiv.offsetWidth,
			//height: myTblDiv.offsetHeight,
			//rows: (myTblDiv.getElementsByTagName('tr')[0]) ? Math.floor(myTblDiv.offsetHeight / myTblDiv.getElementsByTagName('tr')[0].offsetHeight) : 10,
			rows: (myTblDiv.getElementsByTagName('tr')[0]) ? Math.floor(restHeight / myTblDiv.getElementsByTagName('tr')[0].offsetHeight) : 1,
		}})
	}

	attributeChangedCallback(att, old, upd) {
		//console.log('attribute changed', att, old, upd)

		// attributes we need to handle here
		if (att == 'css') {
			this._shadowRoot.children[0].insertAdjacentHTML('afterEnd', `<style>${upd.replace(/\n/g,'')}</style>` )
			return
		}

		// rest send to worker
		this.worker.postMessage({[att]: upd})
	}	/*
	connectedCallback() {
		console.log('added to DOM')
		//this.h3 = this.getAttribute("name")
		//this.render()
	}

	disconnectedCallback() {
		console.log('removed from DOM')
	}

	adoptedCallback() {
		console.log('moved in DOM')
	}

	render() {
		//this.h3
	}
	*/
}

customElements.define('kk-rows', kkRows)
